
<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8">
  <title>Gestione Vendite</title>
  <style>
    body { font-family:Arial,sans-serif; margin:2rem; }
    nav a { margin-right:1rem; text-decoration:none; font-weight:bold; cursor:pointer; }
    nav a.active { text-decoration:underline; }
    table { border-collapse:collapse; width:100%; margin-top:1rem; }
    th, td { border:1px solid #333; padding:0.5rem; text-align:center; }
    input, select { padding:0.3rem; width:100%; box-sizing:border-box; }
    .btn { padding:0.5rem 1rem; background:#007acc; color:#fff; border:none; cursor:pointer; }
    .btn:hover { background:#005fa3; }
    .btn.danger { background:#dc3545; }
    .btn.danger:hover { background:#c82333; }
    .btn.success { background:#28a745; }
    .btn.success:hover { background:#218838; }
    .editable-cell { cursor:text; }
    .date-section { margin-bottom: 1.5rem; padding: 1rem; border: 1px solid #ccc; background-color: #f9f9f9; }
    .date-section h4 { margin-top: 0; }
    .form-group { margin-bottom: 1rem; }
    .form-group label { display: block; margin-bottom: 0.3rem; font-weight: bold; }
    .fieldset-container { border: 1px solid #ccc; padding: 1.5rem; margin-bottom: 2rem; border-radius: 5px; background-color: #fff; }
    .fieldset-container legend { font-weight: bold; font-size: 1.2em; padding: 0 0.5rem; color: #007acc; }
    .btn-group { margin-top: 1.5rem; }
    .hidden { display: none; }
    #preview table { border-collapse: collapse; width: 100%; }
    #preview td, #preview th { border: 2px solid #000; padding: 8px; text-align: center; }
    #preview .editable-cell { background-color: #f9f9f9; }
    #preview .editable-cell:focus { background-color: #fff; outline: 2px solid #007acc; }
    .empty-amount-cell { background-color: #fffacd; cursor: text; }
    .file-controls { margin: 1rem 0; padding: 1rem; background-color: #f8f9fa; border-radius: 5px; }
    .file-controls h4 { margin-top: 0; }
    .status-message { padding: 0.5rem; margin: 0.5rem 0; border-radius: 3px; }
    .status-success { background-color: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
    .status-error { background-color: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
  </style>
</head>
<body>

<nav>
  <a href="#" id="nav-products" class="active">Prodotti</a>
  <a href="#" id="nav-template">Genera Template</a>
</nav>

<div id="products-section">
  <h2>Gestione Prodotti</h2>
  
  <div class="file-controls">
    <h4>Gestione File Prodotti</h4>
    <button class="btn success" onclick="downloadProductsJSON()">üì• Scarica Prodotti (JSON)</button>
    <input type="file" id="fileInput" accept=".json" style="display: none;" onchange="loadProductsFromFile(event)">
    <button class="btn" onclick="document.getElementById('fileInput').click()">üì§ Carica Prodotti (JSON)</button>
    <button class="btn danger" onclick="clearAllProducts()">üóëÔ∏è Cancella Tutti</button>
    <div id="status-message"></div>
  </div>
  
  <div id="edit-product-form" class="hidden">
    <h3>Modifica Prodotto</h3>
    <table>
      <tr><th>Nome</th><th>Prezzo (‚Ç¨)</th><th>Salva</th></tr>
      <tr>
        <td><input id="edit-name" required></td>
        <td><input id="edit-price" type="number" step="0.01" required></td>
        <td><button class="btn" onclick="saveEditProduct()">Salva</button></td>
      </tr>
    </table>
    <button class="btn" onclick="cancelEdit()">Annulla</button>
    <hr>
  </div>

  <table>
    <tr><th>Nome Prodotto</th><th>Prezzo (‚Ç¨)</th><th>Aggiungi</th></tr>
    <tr>
      <td><input id="new-product-name" placeholder="Nome prodotto" required></td>
      <td><input id="new-product-price" type="number" step="0.01" placeholder="‚Ç¨" required></td>
      <td><button class="btn" onclick="addProduct()">Aggiungi</button></td>
    </tr>
  </table>

  <table id="products-table">
    <tr><th>ID</th><th>Nome</th><th>Prezzo (‚Ç¨)</th><th>Modifica</th><th>Elimina</th></tr>
  </table>
</div>

<div id="template-section" class="hidden">
  <h2>Genera Template</h2>
  
  <div id="template-form">
    <div class="fieldset-container">
        <legend>Dati Cliente e Data</legend>
        <div class="form-group">
            <label for="cliente">Cliente:</label>
            <input id="cliente" required>
        </div>

        <div id="date_section_0" class="form-group">
            <label for="date1">Data:</label>
            <input type="date" id="date1" required>
            <table id="single-date-table">
                <thead>
                    <tr><th>Colli</th><th>Prodotto</th><th>KG</th></tr>
                </thead>
                <tbody>
                </tbody>
            </table>
        </div>

        <div class="form-group">
            <label><input type="checkbox" id="multi_date"> Abilita date multiple</label>
        </div>

        <div id="multi_date_section" style="display:none;" class="fieldset-container">
            <legend>Date Aggiuntive</legend>
            <div id="date_sections_container">
            </div>
            <button type="button" id="add_date_btn" class="btn" style="margin-top: 1rem;">Aggiungi Data</button>
        </div>
    </div>

    <div class="btn-group">
        <button class="btn" onclick="generatePreview()">Genera & Preview</button>
    </div>
  </div>

  <div id="preview-section" class="hidden">
    <h3>Preview (valori calcolati)</h3>
    <div id="preview"></div>
    <p><button class="btn" onclick="downloadExcel()">Download .xlsx</button></p>
    <button class="btn" onclick="backToForm()">Torna al Form</button>
  </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
<script>
// Global variables
let products = [];
let currentEditId = null;
let dateCounter = 0;
let previewData = [];

// Initialize
document.addEventListener('DOMContentLoaded', function() {
    loadProducts();
    setupEventListeners();
    document.getElementById('date1').value = new Date().toISOString().slice(0,10);
});

// Funzioni per gestione JSON prodotti
function showStatusMessage(message, isError = false) {
    const statusDiv = document.getElementById('status-message');
    statusDiv.innerHTML = `<div class="status-message ${isError ? 'status-error' : 'status-success'}">${message}</div>`;
    setTimeout(() => {
        statusDiv.innerHTML = '';
    }, 3000);
}

function downloadProductsJSON() {
    if (products.length === 0) {
        showStatusMessage('Nessun prodotto da salvare!', true);
        return;
    }
    
    const dataStr = JSON.stringify(products, null, 2);
    const dataBlob = new Blob([dataStr], {type: 'application/json'});
    const url = URL.createObjectURL(dataBlob);
    const link = document.createElement('a');
    link.href = url;
    link.download = 'prodotti.json';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
    
    showStatusMessage(`File prodotti.json scaricato con ${products.length} prodotti!`);
}

function loadProductsFromFile(event) {
    const file = event.target.files[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            const loadedProducts = JSON.parse(e.target.result);
            
            if (!Array.isArray(loadedProducts)) {
                throw new Error('Il file deve contenere un array di prodotti');
            }
            
            // Validazione struttura prodotti
            for (let product of loadedProducts) {
                if (!product.id || !product.name || typeof product.price !== 'number') {
                    throw new Error('Struttura prodotto non valida. Ogni prodotto deve avere: id, name, price');
                }
            }
            
            products = loadedProducts;
            loadProducts();
            showStatusMessage(`Caricati ${products.length} prodotti dal file JSON!`);
            
        } catch (error) {
            showStatusMessage(`Errore nel caricamento del file: ${error.message}`, true);
        }
    };
    reader.readAsText(file);
    event.target.value = ''; // Reset input
}

function clearAllProducts() {
    if (products.length === 0) {
        showStatusMessage('Nessun prodotto da cancellare!', true);
        return;
    }
    
    if (confirm(`Sei sicuro di voler cancellare tutti i ${products.length} prodotti?`)) {
        products = [];
        loadProducts();
        showStatusMessage('Tutti i prodotti sono stati cancellati!');
    }
}

function setupEventListeners() {
    document.getElementById('nav-products').addEventListener('click', () => showSection('products'));
    document.getElementById('nav-template').addEventListener('click', () => showSection('template'));
    
    document.getElementById('multi_date').addEventListener('change', toggleMultiDateSection);
    document.getElementById('add_date_btn').addEventListener('click', () => addDateSection());
}

function showSection(section) {
    document.querySelectorAll('nav a').forEach(a => a.classList.remove('active'));
    document.querySelectorAll('[id$="-section"]').forEach(s => s.classList.add('hidden'));
    
    if (section === 'products') {
        document.getElementById('nav-products').classList.add('active');
        document.getElementById('products-section').classList.remove('hidden');
        loadProducts();
    } else if (section === 'template') {
        document.getElementById('nav-template').classList.add('active');
        document.getElementById('template-section').classList.remove('hidden');
        buildSingleDateTable();
    }
}

function addProduct() {
    const name = document.getElementById('new-product-name').value.trim();
    const price = parseFloat(document.getElementById('new-product-price').value);
    
    if (!name || isNaN(price)) {
        showStatusMessage('Inserisci nome e prezzo validi', true);
        return;
    }
    
    const newId = Math.max(...products.map(p => p.id), 0) + 1;
    products.push({ id: newId, name: name, price: price });
    
    document.getElementById('new-product-name').value = '';
    document.getElementById('new-product-price').value = '';
    loadProducts();
    showStatusMessage(`Prodotto "${name}" aggiunto!`);
}

function loadProducts() {
    const table = document.getElementById('products-table');
    const tbody = table.querySelector('tbody') || table;
    
    // Clear existing rows except header
    while (tbody.rows.length > 1) {
        tbody.deleteRow(1);
    }
    
    if (products.length === 0) {
        const row = tbody.insertRow();
        row.innerHTML = '<td colspan="5">Nessun prodotto presente. <br><small>Aggiungi prodotti manualmente o carica un file JSON.</small></td>';
        return;
    }
    
    products.forEach(product => {
        const row = tbody.insertRow();
        row.innerHTML = `
            <td>${product.id}</td>
            <td>${product.name}</td>
            <td>${product.price.toFixed(2).replace('.', ',')}</td>
            <td><button class="btn" onclick="editProduct(${product.id})" title="Modifica">‚úèÔ∏è</button></td>
            <td><button class="btn danger" onclick="deleteProduct(${product.id})" title="Elimina">üóëÔ∏è</button></td>
        `;
    });
}

function editProduct(id) {
    const product = products.find(p => p.id === id);
    if (!product) return;
    
    currentEditId = id;
    document.getElementById('edit-name').value = product.name;
    document.getElementById('edit-price').value = product.price;
    document.getElementById('edit-product-form').classList.remove('hidden');
}

function saveEditProduct() {
    const name = document.getElementById('edit-name').value.trim();
    const price = parseFloat(document.getElementById('edit-price').value);
    
    if (!name || isNaN(price)) {
        showStatusMessage('Inserisci nome e prezzo validi', true);
        return;
    }
    
    const productIndex = products.findIndex(p => p.id === currentEditId);
    if (productIndex !== -1) {
        products[productIndex].name = name;
        products[productIndex].price = price;
        cancelEdit();
        loadProducts();
        showStatusMessage('Prodotto modificato con successo!');
    }
}

function cancelEdit() {
    currentEditId = null;
    document.getElementById('edit-product-form').classList.add('hidden');
}

function deleteProduct(id) {
    const product = products.find(p => p.id === id);
    if (!product) return;
    
    if (confirm(`Elimina il prodotto "${product.name}"?`)) {
        products = products.filter(p => p.id !== id);
        loadProducts();
        showStatusMessage(`Prodotto "${product.name}" eliminato!`);
    }
}

function buildSingleDateTable() {
    const tbody = document.querySelector('#single-date-table tbody');
    tbody.innerHTML = '';
    
    if (products.length === 0) {
        const row = tbody.insertRow();
        row.innerHTML = '<td colspan="3">Nessun prodotto disponibile. Vai alla sezione Prodotti per aggiungerne.</td>';
        return;
    }
    
    products.forEach((product, index) => {
        const row = tbody.insertRow();
        row.innerHTML = `
            <td><input name="colli1_${index}" type="number" min="0" value="0"></td>
            <td>${product.name}</td>
            <td><input name="kg1_${index}" type="number" step="0.01" min="0" value="0"></td>
        `;
    });
}

function toggleMultiDateSection() {
    const checkbox = document.getElementById('multi_date');
    const multiSection = document.getElementById('multi_date_section');
    const singleSection = document.getElementById('date_section_0');
    const container = document.getElementById('date_sections_container');
    
    if (checkbox.checked) {
        multiSection.style.display = 'block';
        singleSection.style.display = 'none';
        if (container.children.length === 0) {
            addDateSection(0, new Date().toISOString().slice(0,10));
        }
    } else {
        multiSection.style.display = 'none';
        singleSection.style.display = 'block';
        container.innerHTML = '';
        dateCounter = 0;
    }
}

function addDateSection(initialCounter = null, initialDate = '') {
    if (products.length === 0) {
        showStatusMessage('Aggiungi prima alcuni prodotti nella sezione Prodotti!', true);
        return;
    }
    
    const currentCounter = initialCounter !== null ? initialCounter : ++dateCounter;
    const container = document.getElementById('date_sections_container');
    
    const newSection = document.createElement('div');
    newSection.classList.add('date-section');
    newSection.setAttribute('data-date-index', currentCounter);
    
    let tableRows = '';
    products.forEach((product, index) => {
        tableRows += `
            <tr>
                <td><input name="dates[${currentCounter}][colli][${index}]" type="number" min="0" value="0"></td>
                <td>${product.name}</td>
                <td><input name="dates[${currentCounter}][kg][${index}]" type="number" step="0.01" min="0" value="0"></td>
            </tr>
        `;
    });
    
    newSection.innerHTML = `
        <h4>Data ${currentCounter + 1}</h4>
        <div class="form-group">
          <label>Data:</label>
          <input type="date" name="dates[${currentCounter}][date]" value="${initialDate || new Date().toISOString().slice(0,10)}" required>
        </div>
        <table>
            <thead>
                <tr><th>Colli</th><th>Prodotto</th><th>KG</th></tr>
            </thead>
            <tbody>
                ${tableRows}
            </tbody>
        </table>
        <button type="button" class="btn danger remove-date-btn" style="margin-top: 10px;">Rimuovi Data</button>
    `;
    
    container.appendChild(newSection);
    
    newSection.querySelector('.remove-date-btn').addEventListener('click', function() {
        newSection.remove();
        if (document.getElementById('multi_date').checked && container.children.length === 0) {
            addDateSection(0, new Date().toISOString().slice(0,10));
        }
    });
}

function generatePreview() {
    const cliente = document.getElementById('cliente').value.trim();
    if (!cliente) {
        showStatusMessage('Inserisci il nome del cliente', true);
        return;
    }
    
    if (products.length === 0) {
        showStatusMessage('Nessun prodotto disponibile per generare il template!', true);
        return;
    }
    
    const allEntries = [];
    const multiDate = document.getElementById('multi_date').checked;
    
    if (multiDate) {
        const dateSections = document.querySelectorAll('.date-section');
        dateSections.forEach(section => {
            const dateInput = section.querySelector('input[type="date"]');
            const date = dateInput.value;
            const entries = [];
            
            const colliInputs = section.querySelectorAll('input[name*="[colli]"]');
            const kgInputs = section.querySelectorAll('input[name*="[kg]"]');
            
            colliInputs.forEach((colliInput, index) => {
                const colli = parseInt(colliInput.value) || 0;
                const kg = parseFloat(kgInputs[index].value) || 0;
                
                if (colli > 0 || kg > 0) {
                    entries.push({
                        c: colli,
                        name: products[index].name,
                        kg: kg,
                        price: products[index].price
                    });
                }
            });
            
            if (entries.length > 0) {
                allEntries.push({ date: date, entries: entries });
            }
        });
    } else {
        const date = document.getElementById('date1').value;
        const entries = [];
        
        products.forEach((product, index) => {
            const colliInput = document.querySelector(`input[name="colli1_${index}"]`);
            const kgInput = document.querySelector(`input[name="kg1_${index}"]`);
            
            const colli = parseInt(colliInput.value) || 0;
            const kg = parseFloat(kgInput.value) || 0;
            
            if (colli > 0 || kg > 0) {
                entries.push({
                    c: colli,
                    name: product.name,
                    kg: kg,
                    price: product.price
                });
            }
        });
        
        if (entries.length > 0) {
            allEntries.push({ date: date, entries: entries });
        }
    }
    
    if (allEntries.length === 0) {
        showStatusMessage('Inserisci almeno un prodotto con quantit√† > 0', true);
        return;
    }
    
    generatePreviewTable(cliente, allEntries);
}

function generatePreviewTable(cliente, allEntries) {
    let html = `
        <table id="preview-table" style="width:100%; border-collapse:collapse;">
            <tr>
                <td colspan="5" style="text-align:center; font-weight:bold; font-size:12px; border:2px solid #000; padding:8px;">
                    NOTA DI VENDITA | ${cliente}
                </td>
            </tr>
            <tr style="font-weight:bold;">
                <td style="border:2px solid #000; padding:8px; text-align:center; width:8%;">C</td>
                <td style="border:2px solid #000; padding:8px; text-align:center; width:35%;">PRODOTTO</td>
                <td style="border:2px solid #000; padding:8px; text-align:center; width:12%;">KG</td>
                <td style="border:2px solid #000; padding:8px; text-align:center; width:20%;">PREZZO</td>
                <td style="border:2px solid #000; padding:8px; text-align:center; width:25%;">IMPORTO</td>
            </tr>
    `;
    
    previewData = [];
    let totalAmount = 0;
    
    allEntries.forEach((dateSection, sectionIndex) => {
        if (sectionIndex > 0) {
            html += '<tr><td colspan="5" style="border-top:3px double #000;"></td></tr>';
        }
        
        const displayDate = formatDate(dateSection.date);
        html += `<tr><td colspan="5" style="border:2px solid #000; padding:8px;">Data: ${displayDate}</td></tr>`;
        
        previewData.push({ type: 'date_label', date: dateSection.date });
        
        dateSection.entries.forEach(entry => {
            const amount = entry.kg * entry.price;
            totalAmount += amount;
            
            html += `
                <tr>
                    <td style="border:2px solid #000; padding:8px; text-align:center;" data-col-type="colli">${entry.c}</td>
                    <td style="border:2px solid #000; padding:8px; text-align:center;" data-col-type="product">${entry.name}</td>
                    <td style="border:2px solid #000; padding:8px; text-align:center;" class="editable-cell" data-col-type="kg" contenteditable="true">${entry.kg.toFixed(2)}</td>
                    <td style="border:2px solid #000; padding:8px; text-align:center;" class="editable-cell" data-col-type="price" contenteditable="true">‚Ç¨${entry.price.toFixed(2)}</td>
                    <td style="border:2px solid #000; padding:8px; text-align:center;" class="editable-cell" data-col-type="amount" contenteditable="true">‚Ç¨${amount.toFixed(2)}</td>
                </tr>
            `;
            
            previewData.push({
                type: 'product_row',
                colli: entry.c,
                product_name: entry.name,
                kg: entry.kg,
                price: entry.price,
                amount: amount
            });
        });
    });
    
    // Fill remaining rows up to 22 data rows
    const maxDataRows = 22;
    let currentDataRows = allEntries.reduce((sum, section) => sum + section.entries.length, 0) + allEntries.length; // +sections for date labels
    
    for (let i = currentDataRows; i < maxDataRows; i++) {
        html += `<tr>
            <td colspan="4" style="border:2px solid #000; padding:8px;"></td>
            <td style="border:2px solid #000; padding:8px; text-align:center;" class="empty-amount-cell editable-cell" data-col-type="empty-amount" contenteditable="true">‚Ç¨0,00</td>
        </tr>`;
    }
    
    html += `
        <tr style="font-weight:bold;">
            <td colspan="4" style="border:2px solid #000; padding:8px; text-align:center;">TOTALE</td>
            <td id="totalAmount" style="border:2px solid #000; padding:8px; text-align:center;">‚Ç¨${totalAmount.toFixed(2)}</td>
        </tr>
    </table>`;
    
    document.getElementById('preview').innerHTML = html;
    document.getElementById('template-form').classList.add('hidden');
    document.getElementById('preview-section').classList.remove('hidden');
    
    setupPreviewEventListeners();
}

function setupPreviewEventListeners() {
    const table = document.getElementById('preview-table');
    const totalCell = document.getElementById('totalAmount');
    
    table.addEventListener('input', function(event) {
        const target = event.target;
        if (target.classList.contains('editable-cell') && target.dataset.colType !== 'total') {
            const row = target.closest('tr');
            const type = target.dataset.colType;
            
            if (type === 'empty-amount') {
                // Per le celle vuote dell'importo, aggiorna solo il totale
                recalcTotal();
            } else {
                // Per le altre celle, ricalcola la riga e poi il totale
                recalcRow(row, type);
                recalcTotal();
            }
        }
    });
    
    function clean(v) {
        return parseFloat((v || '').replace('‚Ç¨', '').replace(/[^0-9,.-]/g,'').replace(',','.')) || 0;
    }
    
    function fmt(v) {
        const num = parseFloat(v);
        if (isNaN(num)) return '‚Ç¨0,00';
        return '‚Ç¨' + num.toFixed(2);
    }
    
    function recalcRow(row, modifiedType) {
        const kgCell = row.querySelector('[data-col-type=kg]');
        const priceCell = row.querySelector('[data-col-type=price]');
        const amountCell = row.querySelector('[data-col-type=amount]');
        
        if (!kgCell || !priceCell || !amountCell) return;
        
        let kg = clean(kgCell.textContent);
        let price = clean(priceCell.textContent);
        let amount = clean(amountCell.textContent);
        
        if (modifiedType === 'kg' || modifiedType === 'price') {
            amount = kg * price;
        }
        
        kgCell.textContent = kg.toFixed(2);
        priceCell.textContent = fmt(price);
        amountCell.textContent = fmt(amount);
    }
    
    function recalcTotal() {
        let sum = 0;
        // Somma tutte le celle dell'importo (sia prodotti che celle vuote)
        table.querySelectorAll('[data-col-type=amount], [data-col-type=empty-amount]').forEach(cell => {
            sum += clean(cell.textContent);
        });
        totalCell.textContent = fmt(sum);
    }
}

function formatDate(dateStr) {
    const date = new Date(dateStr);
    return date.toLocaleDateString('it-IT');
}

function backToForm() {
    document.getElementById('template-form').classList.remove('hidden');
    document.getElementById('preview-section').classList.add('hidden');
}

function downloadExcel() {
    const table = document.getElementById('preview-table');
    const cliente = document.getElementById('cliente').value.trim();

    // Creiamo un foglio vuoto
    const ws = XLSX.utils.aoa_to_sheet([]);
    ws['!merges'] = [];
    const rows = table.querySelectorAll('tr');

    // Define the 2px black border style
    const THICK_BORDER = { style: 'medium', color: { rgb: 'FF000000' } }; // 'medium' typically translates to 2px
    const headerRows = new Set();
    const dateRows = new Set();
    const totalRowIndex = -1; // To store the index of the total row

    // Popola il foglio
    rows.forEach((row, rowIndex) => {
        const cells = row.querySelectorAll('td, th');
        let rowData = ['', '']; // Offset by 2 columns (A, B)

        // Riga data o header principale (colspan=5)
        if (cells.length === 1 && cells[0].colSpan === 5) {
            rowData.push(cells[0].textContent.trim(), '', '', '', '');
            dateRows.add(rowIndex);
        }
        // Riga intestazione tabella (5 celle con 'IMPORTO')
        else if (cells.length === 5 && cells[4].textContent.trim() === 'IMPORTO') {
            rowData.push('C', 'PRODOTTO', 'KG', 'PREZZO', 'IMPORTO');
            headerRows.add(rowIndex);
        }
        // Riga dati prodotto
        else if (cells.length === 5) {
            const [colli, prod, kgRaw, priceRaw, amtRaw] = Array.from(cells).map(td => td.textContent.trim());
            // Replace comma with dot for proper number parsing, then format for display
            const kg = parseFloat(kgRaw).toFixed(2).replace('.', ',');
            const price = parseFloat(priceRaw.replace('‚Ç¨', '')).toFixed(2).replace('.', ',');
            const amt = parseFloat(amtRaw.replace('‚Ç¨', '')).toFixed(2).replace('.', ',');
            rowData.push(colli, prod, kg, `‚Ç¨${price}`, `‚Ç¨${amt}`);
        }
        // Riga importo zero
        else if (cells.length === 2 && cells[1].classList.contains('empty-amount-cell')) {
            const amtRaw = cells[1].textContent.trim();
            const amt = parseFloat(amtRaw.replace('‚Ç¨', '')).toFixed(2).replace('.', ',');
            rowData.push('', '', '', '', `‚Ç¨${amt}`);
        }
        // Riga totale
        else if (row.querySelector('#totalAmount')) {
            const total = parseFloat(row.querySelector('#totalAmount').textContent.trim().replace('‚Ç¨', '')).toFixed(2).replace('.', ',');
            rowData.push('', '', '', 'TOTALE', `‚Ç¨${total}`);
            totalRowIndex = rowIndex; // Capture the total row index
        }

        XLSX.utils.sheet_add_aoa(ws, [rowData], { origin: `A${rowIndex + 1}` });
    });

    // Imposta range colonne fino a G
    const range = XLSX.utils.decode_range(ws['!ref']);
    ws['!ref'] = XLSX.utils.encode_range({ s: { r: 0, c: 0 }, e: { r: range.e.r, c: 6 } });

    // Calcolo larghezza colonne con cap e min
    const MIN_WIDTH_FIRST = 10; // larghezza minima per A e B
    const MAX_WIDTH = 30;       // larghezza massima per tutte le colonne
    const colWidths = [];

    for (let c = 0; c <= 6; c++) {
        let maxLen = 0;
        for (let r = 0; r <= range.e.r; r++) {
            const addr = XLSX.utils.encode_cell({ r, c });
            const cell = ws[addr];
            if (cell && cell.v != null) {
                maxLen = Math.max(maxLen, cell.v.toString().length);
            }
        }
        let width = maxLen + 2;
        width = Math.min(width, MAX_WIDTH);
        if (c === 0 || c === 1) width = MIN_WIDTH_FIRST;
        colWidths[c] = { wch: width };
    }
    ws['!cols'] = colWidths;

    // Applica stili
    for (let r = 0; r <= range.e.r; r++) {
        for (let c = 2; c <= 6; c++) { // Apply borders from column C (index 2) to G (index 6)
            const addr = XLSX.utils.encode_cell({ r, c });
            if (!ws[addr]) { // Ensure cell exists before applying style
                 ws[addr] = { t: 's', v: '' }; // Create an empty cell if it doesn't exist to apply style
            }
            
            const isHeader = headerRows.has(r);
            const isDate = dateRows.has(r);
            const isTotalRow = (r === totalRowIndex);

            // Default border for all cells in the relevant columns
            let borderStyle = { 
                top: THICK_BORDER, 
                bottom: THICK_BORDER, 
                left: THICK_BORDER, 
                right: THICK_BORDER 
            };
            
            // Apply font and alignment for header/date rows
            let fontStyle = {};
            let alignmentStyle = {};

            if (isHeader || isDate || isTotalRow) {
                fontStyle = { bold: true };
                alignmentStyle = { horizontal: 'center' };
            }

            // Merge for date rows
            if (isDate) {
                ws['!merges'].push({ s: { r, c: 2 }, e: { r, c: 6 } });
            }

            // Apply styles to the cell
            ws[addr].s = {
                ...ws[addr].s, // Preserve existing styles if any
                border: borderStyle,
                font: fontStyle,
                alignment: alignmentStyle
            };
        }
    }

    // Salva file
    const wb = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(wb, ws, 'Nota di Vendita');
    XLSX.writeFile(wb, `${cliente}.xlsx`);
}
</script>

</body>
</html>